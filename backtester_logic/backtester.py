from momentum_strategy import QuantitativeMomentum
from utils import _int_to_datetime, _datetime_to_int, _ticker_to_table_name
from dateutil.relativedelta import relativedelta
from tqdm import tqdm
import sqlite3
import pandas as pd
import numpy as np


class Backtester():
    """Backtester will take a strategy and return the following statistics about 
    the strategies performance on the sample data 

    - Overall Return
    - Compounded Annual Growth Rate 
    - Standard Deviation
    - Downside Deviation
    - Sharpe Ratio
    - Maximum Drawdown 
    - Worst Month Return 
    - Best Month Return 
    - Profitable months 
    - Equity Time Series  
    """

    def __init__(self, database: str, strategy: (QuantitativeMomentum)) -> None:

        self.strategy = strategy
        self.connector = sqlite3.connect(database)
        self.cursor = self.connector.cursor()

    def _overall_return(self, equity_timeseries: pd.DataFrame, starting_capital: int):
        """Return the overall return generated by the strategy"""
        return (equity_timeseries['Equity'].iloc[-1] / starting_capital) - 1

    def _cagr(self, equity_timeseries: pd.DataFrame, starting_capital: int) -> float:
        """Returns the """
        periods = relativedelta(
            equity_timeseries['Date'].iloc[0], equity_timeseries['Date'].iloc[-1]).years

        return (equity_timeseries['Equity'].iloc[-1] / starting_capital) ** (1 / periods) - 1

    def _std(self, equity_timeseries: pd.DataFrame) -> float:
        """Returns the standard deviation of the timeseries"""

        return equity_timeseries['Equity'].std()

    def _downside_deviation(self, equity_timeseries: pd.DataFrame, minimum_threshold: int = 0) -> float:
        """Returns the downside deviation (measure of downside risk that focuses on returns that fall 
        below a minimum threshold or minimum acceptable return) of equity timeseries """
        returns = equity_timeseries['Equity'].pct_change()
        downside_returns = returns[returns < minimum_threshold]

        squared_deviations = (downside_returns - minimum_threshold) ** 2

        return np.sqrt(squared_deviations.mean())

    def _sharpe_ratio(self, equity_timeseries: pd.DataFrame) -> float:
        """Returns annualized sharpe ratio for a daily time series dataframe"""

        portfolio_data = equity_timeseries.copy()

        portfolio_data['Date'] = pd.to_datetime(
            portfolio_data['Date'], format='%Y%m%d')
        portfolio_data['Daily_Return'] = portfolio_data['Equity'].pct_change()

        risk_free_rates = pd.read_csv('TB3MS.csv')
        risk_free_rates['Date'] = pd.to_datetime(risk_free_rates['Date'])

        merged_data = pd.merge(
            equity_timeseries, risk_free_rates, on='Date', how='left')
        merged_data.loc[0, 'Rate'] = risk_free_rates.loc[0, 'Rate']
        merged_data = merged_data.ffill()
        # convert the rates into daily
        merged_data['Daily_Rate'] = (
            1 + (merged_data['TB3MS'] / 100) / 365) ** (1/91) - 1

        merged_data['Excess_Return'] = portfolio_data['Daily_Return'] - \
            merged_data['Daily_Rate']

        # annualizing sharpe ratio
        return (merged_data['Excess_Return'].mean() / merged_data['Excess_Return'].std()) * (252 ** 0.5)

    def _max_drawdown(self, equity_timeseries: pd.DataFrame) -> float:
        """Returns the worst drawdown in the equity timeseries"""

        rolling_max = equity_timeseries['Equity'].cummax()

        drawdown = (equity_timeseries['Equity'] -
                    rolling_max) / rolling_max * 100

        return drawdown.min()

    def _extreme_month_return(self, equity_timeseries: pd.DataFrame) -> dict:
        """Calculates the extreme month returns (best and worst)"""
        data = pd.read_csv('equity.csv')  # Replace with your file path
        data['Date'] = pd.to_datetime(data['Date'], format='%Y%m%d')
        data.set_index('Date', inplace=True)

        # Calculate the monthly percentage change based on closing prices
        monthly_returns = data['Equity'].resample('M').last().pct_change()

        return {'best': monthly_returns.max(), 'worst': monthly_returns.min()}

    def _profitable_months(self, equity_timeseries: pd.DataFrame) -> float:
        data = equity_timeseries.copy()  # Replace with your file path
        data['Date'] = pd.to_datetime(data['Date'], format='%Y%m%d')
        data.set_index('Date', inplace=True)

        # Calculate the monthly percentage change based on closing prices
        monthly_returns = data['Equity'].resample('M').last().pct_change()

        # Count the number of profitable months (positive percentage change)
        profitable_months = (monthly_returns > 0).sum()

        # Calculate the total number of months
        total_months = len(monthly_returns)

        # Calculate the percentage of profitable months
        return (profitable_months / total_months) * 100

    def _get_statistics(self, equity_timeseries: pd.DataFrame, starting_capital: int) -> dict:
        """Returns relevant statistics"""

        extreme_month_returns = self._extreme_month_return(equity_timeseries)

        return {
            'overall_return': self._overall_return(equity_timeseries, starting_capital),
            'cagr': self._cagr(equity_timeseries),
            'std': self._std(equity_timeseries),
            'downside_deviation': self._downside_deviation(equity_timeseries),
            'sharpe_ratio': self._sharpe_ratio(equity_timeseries),
            'max_drawdown': self._max_drawdown(equity_timeseries),
            'worst_month_return': extreme_month_returns['worst'],
            'best_month_return': extreme_month_returns['best'],
            'profitable_months': self._profitable_months(equity_timeseries)
        }

    def backtest(self, starting_capital: int = 100_000, start_date: int = 19710104, end_date: int = 20230803) -> pd.DataFrame:
        """Runs the backtesting algorithm
            - Will have to loop through all equities and generate signals
            - Will have to deploy optimal amount of capital to each ticker 

        TODO: Make timeseries with pandas and/or numpy 
        TODO: Add statistics calculations in
        """

        query = f"""SELECT Date FROM {_ticker_to_table_name("GE.US")} 
        WHERE Date BETWEEN {start_date} AND {end_date}"""

        equity_timeseries = pd.read_sql_query(query, con=self.connector)

        equity_timeseries['Equity'] = 0

        rebalance_date = _datetime_to_int(
            _int_to_datetime(start_date) + relativedelta(months=3))

        current_portfolio, capital_invested, cash_remaining = self.strategy.portfolio_construction(
            starting_capital, start_date)

        def _calculate_equity(date, capital_invested, portfolio):

            unrealized_change = 0
            for ticker, shares_purcahsed, cost in portfolio:
                query = f'''
                    SELECT
                    Close 
                    FROM {_ticker_to_table_name(ticker)}
                    WHERE Date = {date}
                '''
                return_value = self.cursor.execute(query).fetchone()
                current_price = cost if return_value is None else return_value[0]
                unrealized_change += (current_price - cost) * shares_purcahsed

            return capital_invested + unrealized_change

        # Full backtest
        for current_date in tqdm(equity_timeseries['Date']):

            # Collecting equity changes
            unrealized_equity = _calculate_equity(
                current_date, capital_invested, current_portfolio)

            equity_timeseries.loc[equity_timeseries['Date'] ==
                                  current_date, 'Equity'] = unrealized_equity + cash_remaining

            if current_date >= rebalance_date:
                # on the rebalance date, portfolio is fully sold at the close
                # Ater the close calculate the new portfolio and buy it at the open
                current_portfolio, capital_invested, cash_remaining = self.strategy.portfolio_construction(
                    current_capital=unrealized_equity + cash_remaining,
                    date=current_date
                )

                rebalance_date = _datetime_to_int(
                    _int_to_datetime(current_date) + relativedelta(months=3))

        equity_timeseries.to_csv('equity.csv', index=False)
        return equity_timeseries, self._get_statistics(equity_timeseries, starting_capital)
